#!/usr/bin/env python

###############################################################################
#
# Preprocess the .csv file containing mass-housing raw data.
#
# Usage: ./preprocess <csv file path>
# 
###############################################################################

import sys
import os.path
import csv
import numpy as np
from datetime import date
from sklearn import preprocessing

# output file name
out_name = 'housingdata.arff'

############################# BEGIN FUNCTION DEFINITIONS ######################

# helper function to format column names
def process_name(name):
  name = name.partition('(')[0]
  name = name.translate(None, '&-/')
  name = name.strip()
  return name.replace(' ', '_')

# helper function to process raw data
# takes a file pointer and returns the processed data matrix
# and a list of column names in order
def process_raw_data(data_file):
  today = date.today().toordinal()
  data = []
  grades = []
  column_names = data_file.readline().strip().split(',')
  reader = csv.reader(data_file, dialect='excel')

  # 22 possible codes for detail code column
  codes = ['236DEC','DISPA','ELDER','INTERN','M2W','M2WDEC','MISC',\
            'OPTION','OSDEBT','RAD','RADDEC','RDAL','S8LMSA','S8NCON',\
            'S8SUBR','SEC13A','SEC236','SHARP','SHRDAL','SOFT','TCRED4',\
            'TCRED9']

  # first, build matrix of floating point values from raw data
  for cols in reader:
    row = []
    for i in xrange(len(cols)):
      c_name = column_names[i].lower()
      if 'date' in c_name: # handle date column
        mdy = cols[i].strip().split('/')
        d = date(int(mdy[2]), int(mdy[0]), int(mdy[1])).toordinal()
        row.append(today - d)
      elif 'code' in c_name: # handle detail code column
        for code in codes:
          row.append(1 if cols[i] == code else 0)
      elif 'grade' in c_name: # handle financial rating column
        grade = 0
        if cols[i].upper() == 'A' or cols[i].upper() == 'B' or \
           cols[i].upper() == 'C':
          grade = 1
        grades.append([grade])
      else:
        row.append(0 if cols[i] == '' else cols[i].replace(',',''))
    # convert all values to floating point numbers and append to data matrix
    data.append(map(float, row))

  # create numpy array from list object and scale features
  data_matrix = preprocessing.scale(np.array(data))

  # add grade column last
  data_matrix = np.append(data_matrix, grades, axis=1)

  # second, change column names to match data
  new_column_names = []
  for name in column_names:
      name = name.strip().lower()
      if 'date' in name:
        new_column_names.append(name.replace('date','days since').title())
      elif 'code' in name:
        new_column_names.extend(['Is Detail Code_' + c for c in codes])
      elif 'grade' in name:
        pass
      else:
        new_column_names.append(name.title())
  
  return data_matrix, new_column_names

############################### END FUNCTION DEFINITIONS ######################

# script requires file to be processed
if len(sys.argv) < 2:
  print 'Usage: python preprocess <csv file path>'
  sys.exit(-1)

# ensure file exists
if not os.path.isfile(sys.argv[1]):
  print 'File does not exist:', sys.argv[1]
  sys.exit(-2)

# try to open the file
try:
  data_file = open(sys.argv[1], 'r')
except IOError:
  print 'Error occurred opening file for reading:', sys.argv[1]
  sys.exit(-3)

# read and process data
try:
  data_matrix, column_names = process_raw_data(data_file)
finally:
  data_file.close()

# try to open file for writing
try:
  arff = open(out_name, 'w')
except IOError:
  print 'Error occurred opening file for writing:', out_name
  sys.exit(-4)

# create ARFF file from data
try:
  arff.write('@RELATION masshousingdata\n\n')

  # column names
  for name in column_names:
    arff.write('@ATTRIBUTE ')
    arff.write(process_name(name))
    arff.write(' REAL\n')
  arff.write('@ATTRIBUTE Financial_Rating {1, 0}\n\n')

  # data matrix
  arff.write('@DATA\n')
  np.savetxt(arff, data_matrix, fmt='%1g', delimiter=',', newline='\n')

finally:
  arff.close()
